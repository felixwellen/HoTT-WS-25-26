Eine Gemeinsamkeit mit der Ihnen vertrauten Art Mathematik zu betreiben, ist, dass wir auch weiterhin Buchstaben verwenden, um komplexere Ausdrücke abzukürzen und Funktionen zu definieren - etwa ``$x\mapsto x+1$''. In der Typentheorie gibt es Terme, die wir auch Elemente nennen werden, und Typen. Ein Term hat stets einen Typ. Zum Beispiel werden wir mit ``$n:\N$'' später ausdrücke können, dass $n$ ein Term des Typs $\N$ der natürlichen Zahlen. ``$n:\N$'' ist ein \begriff{Urteil}.
In der Homotopietypentheorie gibt es vier grundlegende Urteile:

\begin{center}
  \begin{tabular}{ll}
    Urteil                        & Bedeutung \\
    \hline
    $ t : A$         & $t$ ist ein Term vom Typ $A$ \\
    $ A$ Typ         & $A$ ist ein Typ \\
    $ A\equiv B$     & $A$ und $B$ sind (urteils-)gleiche Typen \\
    $ t\equiv s : A$ & $t$ und $s$ sind (urteils-)gleiche Terme des Typs $A$ \\
  \end{tabular}
  \label{tab:urteile}
\end{center}

\subsection{Funktionen in einfacher Typentheorie}
Wir werden in diesem Abschnitt ein Fragment einer einfachen Typentheorie betrachten - ``einfach'' bedeutet hier, dass es sich noch nicht um eine abhängige Typentheorie handelt.
Typentheorien bestehen aus einer Liste von Regeln - unsere erste Regel ist:
\begin{center}
 Wenn $A$ und $B$ Typen sind, dann ist $A\to B$ ein Typ.
\end{center}
Regeln, die es erlauben neue Typen zu produzieren, werden auch \begriff{Typformer} genannt.
Das Urteil $f:A\to B$ bedeutet nun dass $f$ ein Term des Typs $A\to B$ ist (also eine Funktion).
Um Terme des Typs $A\to B$ zu konstruieren, muss unter der Annahme $x:A$ ein Term $b(x):B$ angegeben werden:
\begin{center}
  Ist unter der Annahme $x:A$ ein Term $b(x):B$ gegeben, so ist $x\mapsto b(x) : A\to B$.
\end{center}
Regeln die Terme konstruieren nennen wir \begriff{Konstruktoren}\footnote{In der literatur ``Introduction rules''.}.
Schließlich gibt es eine Regel, die es erlaubt Terme des Typs $A\to B$ zu \emph{verwenden}:
\begin{center}
  Seien $f:A\to B$ und $x:A$, dann gibt es einen Term $f(x):B$.
\end{center}
Regeln dieser Art werden \begriff{Eliminatoren} genannt.
\begin{beispiel}
\begin{enumerate}[(a)]
\item Für Typen $A,B,C$ gibt es stets eine Funktion $s$ des Typs
  \[
    (A\to (B\to C)) \to (B\to (A\to C))
  \]
  gegeben durch $f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
\item Wenn wir für einen Moment annehmen, wir hätten bereits einen Typ $\N$ der natürlichen Zahlen und $+:\N\to(\N\to \N)$ dann können wir die folgende Funktion definieren:
\begin{align*}
  d:&\N\to\N \\
    & x\mapsto x+x
\end{align*}
\end{enumerate}
\end{beispiel}

Im ersten Beispiel haben wir gesehen, dass sich Funktionen in zwei Argumenten durch iterierte Typformierung ``$A\to (B\to C)$'' ausdrücken lassen. Man beachte dass das nicht der gleiche Typ wie ``$(A\to B)\to C$'' ist.
\begin{konvention}
  Seien $A,B,C$ Typen. $A\to B\to C$ bezeichnet den Typ $A\to (B\to C)$.
\end{konvention}
Wir verwenden das Zeichen $\colonequiv$ für Definitionen.
Der Text im Beispiel entspricht also der Definition $s\colonequiv f\mapsto (x\mapsto (y \mapsto f(y)(x))$.
Das Symbol $\colonequiv$ passt zusammen mit der definitionalen Gleichheit in der Homotopietypentheorie $\equiv$. Solche Gleichheiten bekommen wir mit den folgenden Regeln:
\begin{center}
  Für $b(x):B$ unter der Annahme $x:A$ und $a:A$ gilt $(x\mapsto b(x))(a)\equiv b(a)$.
\end{center}
Regeln, die auf diese Art Konstruktoren und Eliminatoren verbinden heißen \begriff{Berechnungsregeln}\footnote{In der Literatur ``computation rules''.}
Speziell für Funktionen gibt es noch die sogenannte ``$\eta$-rule'':
\begin{center}
  Für $f:A\to B$ gilt $f\equiv x\mapsto f(x)$.
\end{center}

Wir kommen nun zu unseren ersten Definitionen:
\begin{definition}
  Sei $A$ ein Typ. Dann bezeichnen wir den Term $x\mapsto x:A\to A$ mit $\id_A$.
\end{definition}

\begin{definition}
  Seien $A,B,C$ Typen. Dann ist $\circ:(B\to C)\to (A\to B) \to (A\to C)$ gegeben durch
  \[
    g\mapsto (f\mapsto (x\mapsto g(f(x))))
  \]
  Wir schreiben wie gewohnt $g\circ f$ statt $\circ(g)(f)$.
\end{definition}

\begin{bemerkung}
\begin{enumerate}
\item Für $h:A\to B$ gilt stets $h\circ \id_A\equiv h\equiv \id_B\circ h$.
  Das lässt sich durch auffalten der Definitionen von ``$\circ$'' und ``$\id_A$'', mehrfaches Anwenden der Berechnungsregel und schließlich einer Anwendung der $\eta$-Regel zeigen - wir zeigen nur $h\circ \id_A\equiv h$:
  \begin{align*}
    h\circ \id_A &\equiv (g\mapsto (f\mapsto (x\mapsto g(f(x)))))(h)(\id_A) \\
    &\equiv (f\mapsto (x\mapsto h(f(x))))(\id_A) \\
    &\equiv x\mapsto h(\id_A(x)) \\
    &\equiv x\mapsto h((y\mapsto y)(x)) \\
    &\equiv x\mapsto h(x) \\
    &\equiv h
  \end{align*}
\item In den Übungen werden wir sehen: $h \circ (g\circ f)\equiv (h\circ g)\circ f$.
\end{enumerate}
\end{bemerkung}

\subsection{Abhängige Funktionen}
Wir wollen nun die Regeln des letzten Abschnitts verallgemeinern.
Dafür gibt es verschiedene Gründe. Der wichtigste ist, dass wir Prädikate in der Typentheorie haben wollen und einen verallgemeinerten Funktionstyp als $\forall$-quantor verwenden wollen.

Ein abhängiger Typ ist nichts weiter als ein Ausdruck $B(x)$, der unter der Annahme $x:A$ ein Typ ist.

\begin{beispiel}
  Wir greifen etwas vorweg um konkrete Beispiele zu geben.
  Für $n:\N$ werden wir noch einen Typ $L(n)$ der Listen der Länge $n$ von natürlichen Zahlen konstruieren. Weiter wird es später auch möglich sein, etwa den Typ der Teiler einer natürlichen Zahl zu definieren. Oder einen Typ, der genau dann Terme hat, wenn eine natürliche Zahl eine andere teilt.
\end{beispiel}

Die Regeln für Funktionstypen aus dem letzten Abschnitt lassen sich nun wie folgt für \begriff{abhängige Funktionen} verallgemeinern:

\begin{regeln}
\begin{itemize}
\item Sei für $x:A$ ein Typ $B(x)$ gegeben, dann ist $(x:A)\to B(x)$\index{$(x:A)\to B(x)$} ein Typ. 
\item Sei für $x:A$ ein Term $b(x):B(x)$ gegeben, dann ist $x\mapsto b(x) : (x:A)\to B(x)$\index{$x\mapsto b(x)$}. 
\item Für $f:(x:A)\to B(x)$ und $a:A$ gibt es $f(a):B(a)$. 
\item Sei für $x:A$ ein Term $b(x):B(x)$ gegeben und $a:A$, dann $(x\mapsto b(x))(a)\equiv b(a)$. 
\item Für $f:(x:A)\to B(x)$ ist $(x\mapsto f(x))\equiv f$.
\end{itemize}
\end{regeln}

Statt $(x:A)\to B(x)$ schreiben wir auch $\prod_{x:A}B(x)$.
Falls $B(x)$ konstant ein Typ $C$ ist, schreiben wir auch $A\to C$ und sind damit kompatibel zum vorangegangenen Abschnitt.
Außerdem ist es manchmal hilfreich mehr Typen anzugeben als unbedingt notwendig - zum Beispiel hilft es zur Lesbarkeit den Typ der Variable in Funktionsausdrücken anzugeben: $(x:A)\mapsto b(x)$\index{$(x:A)\mapsto b(x)$}.

\subsection{Natürliche Zahlen}
Ähnlich wie bei dem Funktionstyp beschreiben wir die natürlichen Zahlen auch darüber, wie man Elemente erzeugen und verwenden kann.
Die Formierungsregel ist denkbar einfach: Es gibt einen Typ $\N$\index{$\N$}.

Die \begriff{natürlichen Zahlen} $\N$ haben \emph{zwei} Konstruktoren:
\begin{center}
\begin{tabular}{l}
  Es gibt $0:\N$. \\
  Für jedes $n:\N$ gibt es einen Nachfolger $S(n):\N$\index{$S(n)$}.
\end{tabular}
\end{center}
Dass wir hier ``Nachfolger'' schreiben hat keine formale Bedeutung.
\begin{beispiel}
Wir können nun natürliche Zahlen angeben: $0$, $1\colonequiv S(0)$, $2\colonequiv S(1)$, \dots.
\end{beispiel}
Der Eliminator ist auf den ersten Blick vielleicht etwas undurchsichtig, wird aber sicher schnell klarer durch Beispiele:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$ und $p_S:(x:\N)\to (P(x)\to P(S(x)))$ dann gibt es
  $\elim_\N(p_0,p_S):(x:\N)\to P(x)$.
\end{center}
Wir betrachten zunächst den Fall, dass $P(x)$ konstant ein Typ $A$ ist.
Dann sind die ``Eingangsdaten'' für den Eliminator ein $a:A$ und eine Funktion $\N\to (A\to A)$.
In diesem Fall spricht man auch von \begriff{Rekursion}.
Wenn man eine Funktion $f:\N\to A$ durch Rekursion definiert, gibt man üblicherweise an, was im Fall $n\equiv 0$ passiert und wie man aus $f(n)$ den nächsten Wert $f(n+1)$ konstruiert.
Diese beiden Fälle entsprechen genau den Daten $a:A$ und $r:\N\to (A\to A)$.
\begin{beispiel}
  Wir können Verdopplung $d:\N\to \N$ von natürlichen Zahlen definieren durch:
  \[d\colonequiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))\rlap{.}\]
\end{beispiel}
Um die soeben definierte Funktion testen zu können, benötigen wir die Berechnungsregel für $\N$:
\begin{center}
  Sei $P(x)$ ein Typ für $x:\N$.
  Seien weiter $p_0:P(0)$, $p_S:(x:\N)\to (P(x)\to P(S(x)))$ und $n:\N$
  dann gelten $\elim_\N(p_0,p_S)(0)\equiv p_0$ und $\elim_\N(p_0,p_S)(S(n))\equiv p_S(n)(\elim_\N(p_0,p_S)(n))$.
\end{center}
Damit können wir nun zum Beispiel berechnen:
\begin{align*}
  d(2)&\equiv \elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(1)) \\
      &\equiv (n\mapsto (k\mapsto S(S(k))))(1)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(1)) \\
      &\equiv (k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(1)) \\
      &\equiv S(S(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(S(0)))) \\
      &\equiv S(S((n\mapsto (k\mapsto S(S(k))))(0)(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S((k\mapsto S(S(k)))(\elim_\N(0,n\mapsto (k\mapsto S(S(k))))(0)))) \\
      &\equiv S(S(S(S(0)))) \\
      &\equiv 4
\end{align*}

Um definitionen übersichtlicher darzustellen, verwenden wir \begriff{Pattern-matching}:

\begin{konvention}
\begin{enumerate}[(a)]
\item Definitionen der Form $f\colonequiv x\mapsto b(x)$ erlauben wir uns von nun an auch als
  \begin{align*}
    f(x)\colonequiv b(x)
  \end{align*}
  zu schreiben. 
\item Definitionen wie in obigem Beispiel schreiben wir auch in der folgenden Form
  \begin{align*}
    d(0)&\colonequiv 0 \\
    d(S(n))&\colonequiv S(S(d(n))) 
  \end{align*}
  - wenn die Übersetzung in Eliminatoraufrufe klar ist.
  Diese Form einer Definition nennen wir \begriff{Pattern-Matching}.
\item (a) und (b) dürfen kombiniert werden, wie in der folgenden Definition von ``$+$''.
\end{enumerate}
\end{konvention}

Nun wählen wir $\N\to\N$ für den Zieltyp im Eliminator um die Addition zu definieren.
Wie bei der Komposition ``$\circ$'' wollen wir eine Operatorschreibweise verwenden.
Wir geben von nun an durch Unterstriche vor, wo die Argumente eines Operators stehen sollen (``$\_+\_$'' unten) und verwenden die Operatorschreibweise direkt in der Definition.
\begin{definition}
  Die Funktion $\_+\_:\N\to (\N\to \N)$ ist gegeben durch
  \begin{align*}
    \_+\_:&\N\to (\N\to \N) \\
      0+n&\colonequiv n \\
     S(n)+k&\colonequiv S(n+k)
  \end{align*}
\end{definition}

\begin{bemerkung}
  Per Definition gilt $0+n\equiv n$, aber wir können nicht erwarten, dass auch $n+0\equiv n$ gilt.
  Um die üblichen Gesetze der Addition auf den natürlichen Zahlen zu zeigen, brauchen wir die Objektgleichheit ``$=$'', die wir später einführen werden.
\end{bemerkung}

\subsection{Weitere induktive Typen}
Die natürlichen Zahlen wie sie im letzten Abschnitt eingeführt wurden, sind ein Spezialfall eines
\begriff{induktiven Typen}s. In diesem Abschnitt werden wir weitere Beispiele kennen lernen.

Der \begriff{Einstyp} $\mathbf{1}$\index{$\mathbf{1}$} hat einen Konstruktor ohne Argumente.
Daraus ergeben sich die folgenden Regeln:

\begin{regeln}
\begin{itemize}
\item Es gibt den Typ $\mathbf{1}$. 
\item Es gibt $\ast:\mathbf{1}$. 
\item Für einen Typ $A(x)$ unter der Annahme $x:\mathbf{1}$ und $a:A(\ast)$
gibt es $\elim_{\mathbf{1}}(a):(x:\mathbf{1})\to A(x)$.
\item Für einen Typ $A(x)$ unter der Annahme $x:\mathbf{1}$ und $a:A(\ast)$
gilt $\elim_{\mathbf{1}}(a)(\ast)\equiv a$.
\end{itemize}
\end{regeln}

Ein noch minimalerer Fall ist der \begriff{leere Typ} $\emptyset$\index{$\emptyset$},
der keinen Konstruktor hat und damit nur zwei Regeln:

\begin{regeln}
\begin{itemize}
\item Es gibt den Typ $\emptyset$. 
\item Sei $A(x)$ ein Typ für $x:\emptyset$, dann gibt es $\elim_\emptyset:(x:\emptyset)\to A(x)$.
\end{itemize}
\end{regeln}

Es ist möglich, Typen als Parameter für induktive Definitionen zu verwenden.
Ein wichtiges Beispiel, das uns noch begleiten wird, ist das \begriff{Koprodukt} $A\sqcup B$\index{$A\sqcup B$}, das ein induktiver Typ mit zwei Konstruktoren ist.

\begin{regeln}
Seien $A,B$ Typen.
\begin{itemize}
\item Es gibt den Typ $A\sqcup B$.
\item Für jedes $a:A$ gibt es $\iota_1(a):A\sqcup B$.
  Und für jedes $b:B$ gibt es $\iota_2(b):A\sqcup B$.
\item Sei $P(x)$ ein Typ für $x:A\sqcup B$.
  Für $p_1:(y:A)\to P(\iota_1(y))$ und $p_2:(z:B)\to P(\iota_2(z))$
  gibt es $\elim_\sqcup(p_1,p_2):(x:A\sqcup B)\to P(x)$.
\item Sei $P(x)$ ein Typ für $x:A\sqcup B$.
  Für $p_1:(y:A)\to P(\iota_1(y))$ und $p_2:(z:B)\to P(\iota_2(z))$
  gilt $\elim_\sqcup(p_1,p_2)(\iota_1(y))\equiv p_1(y)$ für $y:A$
  und  $\elim_\sqcup(p_1,p_2)(\iota_2(z))\equiv p_1(z)$ für $z:B$.
\end{itemize}
\end{regeln}

\begin{bemerkung}
Sei $A$ ein Typ. Es gibt Funktionen
  \begin{align*}
    \varphi: &A\to \emptyset\sqcup A &\psi:\emptyset\sqcup A \to A \\
    \varphi(a)&\colonequiv \iota_2(a) &\psi(\iota_2(a))\colonequiv a 
\end{align*}
Die Pattern-Matching-Definition auf der rechten Seite ist vollständig, weil wir im Fall ``$\iota_1$'' auf den leeren Typ matchen und damit null Fälle zu klären haben.
\end{bemerkung}

\subsection{Gleichheit}
\begin{konvention}
\begin{enumerate}[(a)]
\item Statt $f(x)(y)$ schreiben wir auch $f(x,y)$.
\item Typformer für Induktive Typen binden stärker als ``$\to$''. Wir können als zum Beispiel $A\to B\sqcup C$'' schreiben für Funktionen in ein Koprodukt.
\item Wir sagen nun auch gelegentlich, dass wir \begriff{Induktion} verwenden und meinen damit, dass wir den Eliminator eines induktiven Typs verwenden.
\item Gelegentlich schreiben wir das Motiv eines Eliminators, also $P(x)$ an den Eliminator: $\elim_{\N,P}(\dots)$.
\end{enumerate}
\end{konvention}

Für die Addition auf den natürlichen Zahlen $\N$ gilt per Definition für alle $n:\N$:
\[
  0+n\equiv n
\]
Jedoch ist es nicht möglich $n+0\equiv n$ zu zeigen, auch wenn wir für jedes konkrete $k:\N$ wie zum Beispiel 17 sehr wohl zeigen können, dass diese Urteilsgleichheit gilt.
Wir können die Induktion nicht auf das Problem $n+0\equiv n$ anwenden, da es sich dabei nicht um einen abhängigen Typen, sondern um ein Urteil handelt.

Wir wollen uns nun der eigentlichen Gleichheit zuwenden und von nun an mit ``gleich'' die im folgenden eingeführte Gleichheit meinen und nicht die Urteilsgleichheit.
Die Gleichheit in der Homotopietypentheorie ist ein Typ, der nur für zwei Terme des gleichen Typs überhaupt geformt werden kann.
So können wir etwa Fragen, ob zwei natürliche Zahlen gleich sind -- und in diesem Fall wird sich auch herausstellen, dass das eine entscheidbare Frage ist.

Am Ende des letzten Abschnitts hatten wir bereits gesehen, dass Typen von anderen Typen abhängen können. Gleichheit ist ein Typ, der von \emph{Termen} eines Typs abhängt.
Wir werden nun die Regeln für Gleichheit vorstellen und danach im Einzelnen erklären.

\begin{regeln}
\begin{itemize}
\item Sei $A$ ein Typ und seinen weiter $x,y:A$. Dann ist $x=_Ay$\index{$x=_Ay$} ein Typ -- der \begriff{Gleichheitstyp}. Zur Abgrenzung von Urteilsgleichheit sprechen wir hier auch vom \begriff{Identitätstyp} oder \begriff{Objektgleichheit}\footnote{In der Literatur sind noch verbreitet: ``Propositional equality'', ``Paths'' und ``Typal equality''}. Wir schreiben manchmal auch nur $x=y$.
\item Für $x:A$ gibt es $\refl_x:x=_Ax$\index{$\refl_x$}. Wir schreiben auch einfach $\refl$\index{$\refl$}.
\item Sei $P(x,y, p)$ ein Typ für $x,y:A$ und $ p:x=_Ay$.
  Für $r_{x}:P(x,x,\refl_x)$ gibt es
  \[
    \elim_{=,P}(r):(x\ y : A) \to ( p : x=_Ay) \to P(x,y, p)\rlap{.}
  \]
\item \dots und es gilt $\elim_{=,P}(r)(x,x,\refl_x)\equiv r_x$.
\end{itemize}
\end{regeln}

Der Eliminator wird auch Gleichheitsinduktion oder ``J-Rule'' genannt -- wie am Anfang des Abschnitts angekündigt, wollen wir uns die Möglichkeit lassen, das Motiv $P$ als Index anzugeben.
In Worten sagt der Eliminator inetwa, dass es genug ist eine Konstruktion, die eine Gleichheit verwendet, für die reflexive Gleichheit ``$\refl_x:x=x$'' anzugeben.
Umso erstaunlicher ist es, dass es möglich ist, diese Gleichheiten als Pfade in Räumen zu interpretieren. Wir werden immer mal wieder auf diese Sicht eingehen.

Wir können nun Aussagen über die induktiven Typen aus dem vorangegangenen Abschnitt machen.
\begin{bemerkung}
  Für jedes $x:\eins$ gilt $x=\ast$.
  Damit meinen wir, dass es einen Term des Typs $(x:\eins)\to x=\ast$ gibt.
\end{bemerkung}
\begin{beweis}
  Wir verwenden den Eliminator für $\eins$.
  Als Motiv verwenden wir $P(x)\colonequiv x=\ast$. Also müssen wir, um $(x:\eins)\to P(x)$ zu zeigen einen Term $P(\ast)$ finden. Der ist durch $\refl_\ast$ gegeben. 
\end{beweis}

\begin{bemerkung}
  Sei $\zwei$ analog zu $\eins$ definiert, mit Konstruktoren $0_\zwei$ und $1_\zwei$.
  Dann gilt $(x:\zwei)\to (x=0_\zwei)\sqcup (x=1_\zwei)$.
\end{bemerkung}
\begin{beweis}
  Wir müssen ein Element des Typs $(x=0_\zwei)\sqcup (x=1_\zwei)$ produzieren.
  Mit dem Eliminator, reicht es das für die Fälle $0_\zwei$ und $1_\zwei$ zu machen.
  Das ist mit den Termen $\iota_1(\refl_{0_\zwei})$ und $\iota_2(\refl_{1_\zwei})$ erledigt.
\end{beweis}

Nun werden wir einige allgemeine Operationen auf Gleichheitstypen konstruieren.
Die folgenden zwei Operationen können einerseits als die übliche Symmetrie und Transitivität von Äquivalenzrelationen gesehen werden, aber auch als Umdrehen und Aneinanderhängen von Pfaden in einem Raum.

\begin{definition}
  Seien $A$ ein Typ und $x,y:A$.
  Die \begriff{Inversion}\index{$\_^{-1}$} von Gleichheiten ist gegeben durch
  \begin{align*}
    \_^{-1} &: x=_Ay\to y=_Ax \\
    \refl_x^{-1}&\colonequiv \refl_x 
  \end{align*}
  Wir können diese Definition mit dem Eliminator äquivalent wie folgt angeben ($P(x,y, p)$ ist hier $y=_Ax$):
  \[
     \_^{-1}\colonequiv \elim_=((z:A) \mapsto \refl_z)(x,y)\rlap{.}
  \]
\end{definition}

\begin{definition}
  Seien $A$ ein Typ und $x,y,z:A$.
  Die \begriff{Konkatenation}\index{$\_\kon\_$} von Gleichheiten ist gegeben durch
  \begin{align*}
    \_\kon\_&:x=y\to y=z\to x=z \\
    \refl_x\kon \refl_x &\colonequiv  \refl_x
  \end{align*}
  Als Eliminator: $\_\kon\_\colonequiv \elim_=((x:A)\mapsto \id_{x=z})$.
\end{definition}

In der klassischen Mathematik ist es klar, dass Funktionen Gleichheit erhalten -- in der Typentheorie müssen wir das zeigen.
Genauer gesagt, wollen wir eine Operation definieren, die Gleichheiten zwischen zwei Werten auf Gleichheiten zwischen den Bildern abbildet.
Diese Operation wird typischerweise mit ``$\ap$'' wie ``application'' bezeichnet, weil man eine Funktion auf Gleichheiten anwendet. 
Wir wollen das auch direkt in der Schreibweise ausdrücken und $f( p)$ für eine Funktion $f:A\to B$ und eine Gleichheit $ p:x=y$ schreiben.

\begin{definition}\index{$\ap_f$}
  Seien $f:A\to B$ eine Funktion $x,y:A$ und $ p:x=_Ay$.
  Dann ist
  \begin{align*}
    f(\_) &: x=_Ay\to f(x)=_Bf(y) \\
    f(\refl_x)&\colonequiv \refl_{f(x)}
  \end{align*}
  die Anwendung von $f$ auf $ p$. Wir schreiben auch $\ap_f$ für $f(\_)$.
\end{definition}

Nun können wir mehr konkrete Gleichheiten zeigen.
Zum Beispiel können wir mehr über den Identitätstyp von $\eins$ sagen.

\begin{lemma}
  Für $x,y:\eins$ gilt stets $x=y$.  
\end{lemma}
\begin{beweis}
 Das könnte man durch Induktion nach $x$ und $y$ zeigen,
 aber zur Übung verwenden wir die Gleichheitsoperationen und dass wir bereits $\varphi:(z:\eins)\to z=\ast$ haben.
 Wir haben also $\varphi(x):x=\ast$ und $\varphi(y):y=\ast$.
 Und damit: $\varphi(x)\kon\varphi(y)^{-1}:x=y$.
\end{beweis}

\begin{lemma}
\label{nat-wild-monoid}
\begin{enumerate}[(a)]
\item Für alle $n:\N$ gilt $n+0=n$ und $0+n=n$.
\item Für alle $n,k:\N$ gilt $n+k=k+n$.
\item Für alle $n,k,l:\N$ gilt $(n+k)+l=n+(k+l)$.
\end{enumerate}
\end{lemma}
\begin{beweis}
\begin{enumerate}[(a)]
\item Die zweite Gleichung gilt per Definition von $+$,
  für die erste, $n+0=n$, verwenden wir Induktion.
  Per Definition von $+$ haben wir $0+0\equiv 0$ und können diesen Fall somit durch $\refl_0$ klären.
  Es bleit also ein Term in $S(n)+0=S(n)$ zu konstruieren, wobei wir $ p:n+0=n$ verwenden dürfen.
  Per Definition von $+$ ist $S(n)+0\equiv S(n+0)$, womit unser Ziel eigentlich $S(n+0)=S(n)$ ist.
  Das bekommen wir jetzt durch Anwenden der Funktion $S$ auf die Gleichheit $ p$, i.e.\ $S( p):S(n+0)=S(n)$.
\item Wir zeigen zunächst: Für alle $n,k:\N$ haben wir $ p_{n,k}S(n+k)=n+S(k)$.
  Wir verwenden Induktion über $n$.
  Für den ersten Fall müssen wir $S(0+k)=0+S(k)\equiv S(k)$ zeigen, wofür wir (a) verwenden können.
  Für $S(S(n)+k)=S(n)+S(k)$,
  was mit den Urteilsgleichheiten der Definition von $+$ zu $S(S(n+k))=S(n+S(k))$ wird,
  wenden wir auf die ``Induktionsvoraussetzung'' $S(n+k)=n+S(k)$ die Funktion $S$ an.

  Nun zur eigentlichen Gleichung $n+k=k+n$.
  Wir verwenden wieder Induktion über $n$.
  Der Fall für $0$ ist $k=k+0$, was durch Inversion aus (a) hervor geht.
  Für den Fall $S(n+k)=k+S(n)$ wenden wir zunächst $S$
  auf die Induktionvoraussetzung an um $ r:S(n+k)=S(k+n)$ zu bekommen.
  Damit ist $ r\kon p_{k,n}$ eine Lösung.
\item Wird eine Aufgabe auf Übungsblatt 2 sein.
\end{enumerate}
\end{beweis}

\Cref{nat-wild-monoid} zeigt, dass $(\N,+,0)$ ein sogenanntes \begriff{wildes Monoid} ist -- um ein Monoid zu sein, müsste es neben den Gleichungen oben auch eine Menge sein. Den Begriff Menge werden wir erst im nächsten Kapitel definieren.

Die Gleichheitstypen eines jeden Typs tragen eine ähnliche Struktur bzgl $\kon$ wie wir gerade für $\N$ und $+$ gesehen haben -- bis auf die Kommutativität, dafür haben wir so etwas wie Inverse:

\begin{lemma}
\label{gliecheits-gruppoid}
\begin{enumerate}[(a)]
\item Für alle $ p:x=_Ay$ gilt: $ p\kon\refl_y=_{x=_Ay} p$ und $\refl_x\kon p= p$.
\item Für alle $ p:x=y$ haben wir $ p\kon p^{-1}=\refl_x= p^{-1}\kon p$.
\item Für alle $ p:x=_Ay$, $ q:y=_Az$, $ r:z=_Au$ gilt
   $( p\kon q)\kon r= p\kon( q\kon r)$.
\end{enumerate}
\end{lemma}
\begin{beweis}
\begin{enumerate}[(a)]
\item Mit Induktion über $p$ bleibt zu zeigen:
 \[
    (x:A) \to \refl_x\kon\refl_x=\refl_x
 \]
 Nach Definition von $\kon$ gilt $\refl_x\kon\refl_x\equiv\refl_x$ also ist für jedes $x:A$ bereits $\refl_{\refl_x}:\refl_x\kon\refl_x=\refl_x$.
 \item Übungslatt 2.
 \item Übungslatt 2.
\end{enumerate}
\end{beweis}

Später, in der Homotopietypentheorie, werden wir sehen, dass es in manchen Typen mehrere verschiedene Gleichheiten zwischen Elementen gibt.
Die Struktur, die von den Gleichheitstypen eines festen Typs gebildet wird, nennt man \begriff{$\infty$-Grouppoid}, was den Begriff der Gruppe aus der Algebra verallgemeinert. Erstens brauchen Gleichheiten passende Typen, um überhaupt verknüpfbar zu sein (das ist das ``oid'' in ``Gruppoid'') und zweitens gibt es neben den Gesetzen wie Neutralität und Assoziativität auch sogennante höhere Kohärenzen (das ist das ``$\infty$''), die beschreiben wie sich etwa die Assoziativitäts\emph{operation} unter Konkatenation verhält (siehe Übungsblatt 2, letzte Aufgabe).

Nun wenden wir uns einem weiteren, elemtaren Aspekt der Gleichheit zu.
Wir können in der klassischen Mathematik gleiche Dinge grundsätzlich durcheinander ersetzen -- das geht in der Typentheorie nur mit der urteilsmäßigen Gleichheit.
Mit der Objektgleichheit ist das Ersetzen etwas subtiler.
Statt syntaktischem Ersetzen, wendet man eine Funktion an, den sogenannten \emph{Transport}.
Dieser Name kommt aus der Topologie, vom Transport, etwa in einem Faserbündel entlang eines Pfades in der Basis.

\begin{definition}
  Sei $B(x)$ ein Typ für $x:A$.
  Seien weiter $y:A$ und $p:x=_Ay$, dann ist der \begriff{Transport}\index{$\transp_B(p)$} in $B$ entlang von $p$
  \[
    \transp_B(p): B(x)\to B(y)
  \]
  gegeben durch $\transp_B(\refl_x)\colonequiv \id_{B(x)}$.  
\end{definition}

Der Transport verhält sich \emph{funktoriell}, d.h.\ dass zum Beispiel die Konkatenation von Gleichheiten mit der Komposition der Transporte zusammenpasst:

\begin{lemma}
  Sei $A$ ein Typ und $x,y,z:A$. Für alle $p:x=y$ und $q:y=z$ haben wir
  \[
    \transp_B(p\kon q) = \transp_B(q) \circ \transp_B(p)\rlap{.}
  \]
\end{lemma}
\begin{beweis}
  Induktion über $p$ und $q$.
\end{beweis}

Wir werden immer wieder für konkrete $B$ auch konkrete Beschreibungen für den Transport in $B$ finden.
Einen Anfang machen wir mit Transporten in Gleichheitstypen.

\begin{lemma}
  \label{transport-gleichheitstyp}
  Seien $A$ ein Typ und $x_0,x_0:A$.
  \begin{enumerate}[(a)]
  \item Sei $B(x)\colonequiv x=y_0$. Für alle $p:u=_Av$ und alle $q:u=y_0$ gilt $\transp_B(p)(q)=q^{-1}\kon p$.
  \item Sei $C(y)\colonequiv x_0=y$. Für alle $p:u=_Av$ und alle $q:x_0=u$ gilt $\transp_C(p)(q)=q\kon p$.
  \end{enumerate}
\end{lemma}
\begin{beweis}
  Induktion über $p$.
\end{beweis}

\subsection{Abhängige Summen}
Mit der abhängigen Summe werden wir nun eine etwas zu starke Version des Existenzquantors, aber auch eine Verallgemeinerung des Produkts zweier Mengen ``$A\times B$'' kennen lernen.
Weiter kann die abhängige Summe auch als Verallgemeinerung des Koprodukts mit beliebigem Index ``$\coprod_{i\in I}X_i$'' verstanden werden.
In der Homotopietypentheorie kann man die abhängige Summe auch als Totalraum einer Faserung verstehen.

Die Regeln folgen wieder dem Schema für induktive Typen.

\begin{regeln}
\begin{itemize}
\item Sei $B(z)$ ein Typ für $z:A$. Dann gibt es den Typ $(z:A)\times B(z)$ oder auch $\sum_{z:A}B(z)$,
  die \begriff{abhängige Summe}\index{$(z:A)\times B(z)$}\index{$\sum_{z:A}B(z)$}.
  $(z:A)\times B(z)$ wird auch Typ der \begriff{abhängigen Paare} genannt.
  Im Fall eines konstanten Typs $B$ schreiben wir auch $A\times B$.
\item Für $a:A$ und $b:B(a)$ gibt es $(a,b):(z:A)\times B(z)$.
\item Sei $P(u)$ ein Typ für $u:(z:A)\times B(z)$.
  Für $p:(z:A) \to (y : B(z)) \to P((z,y))$ gibt es $\elim_{\sum,P}(p):(u:(z:A)\times B(z))\to P(u)$.
\item \dots und es gilt $\elim_{\sum,P}(p)((z,y))\equiv p(z,y)$.
\end{itemize}
\end{regeln}

Wir wollen nun die verallgemeinerten Projektionen definieren - analog zu $\pi_1:A\times B\to A$ und $\pi_2:A\times B\to B$.

\begin{definition}
  Sei $B(x)$ Typ für $x:A$.
  Dann ist die durch
  \begin{align*}
      &\pi_1:((x:A) \times B(x))\to A \\
      &\pi_1((x,y))\colonequiv x
  \end{align*}
  gegebene Abbildung die \begriff{Projektion}\index{$\pi_1$} auf den ersten Faktor.
  Weiter ist die durch\index{$\pi_2$}
  \begin{align*}
      &\pi_2:((x:A) \times B(x))\to B(\pi_1(x)) \\
      &\pi_2((x,y))\colonequiv y
  \end{align*}
  gegebene Abbildung die Projektion auf den zweiten Faktor.
\end{definition}

\begin{konvention}
  $\times$ bindet stärker als $\to$ und $\sqcup$.
\end{konvention}

Nun können wir - ähnlich wie bei einfacheren induktiven Typen - auch für die Natürlichen Zahlen etwas in die Richtung zeigen, dass alle Elemente durch die Konstruktoren gegeben sind.

\begin{bemerkung}
  Wir haben $(n:\N)\to x=0 \sqcup (k:\N)\times n=S(k)$ per Induktion über $n$.
  Für den Fall $0$ verwenden wir $\iota_1(\refl_0)$ und für $n\equiv S(k)$ verwenden wir $\iota_2((k,\refl_{S(k)}))$.
\end{bemerkung}

Wir können nun auch in Definitionen Existenz im starken Sinn der abhängigen Summe verwenden.

\begin{definition}
  Ein Typ $A$ heißt \begriff{kontrahierbar}\index{$\isContr$}, wenn der folgenden Typ bewohnt ist:
\[
  \mathrm{\isContr}(A)\colonequiv (x:A)\times ((y:A)\to y=x)\rlap{.}
\]
  Für einen Zeugen $z:\isContr(A)$ nennt man $\pi_1(z)$ das \begriff{(Kontraktions-)zentrum}
  und $\pi_2(z)$ die \begriff{Kontraktion}.
\end{definition}

Wir haben bereits ein Beispiel:
\begin{beispiel}
  Der Typ $\eins$ ist kontrahierbar: Als Zentrum nehmen wir $\ast:\eins$ und
  eine Kontraktion $k$ können wir durch $k(\ast)\colonequiv \refl_\ast$ definieren.
\end{beispiel}

Nachdem wir etwas mehr über Gleicheit in abhängigen Summen wissen, werden wir ein wichtiges Beispiel für einen Kontrahierbaren Typ sehen.
Interessanterweise lassen sich die Gleichheitstypen einer abhängigen Summe durch abhängige Summen beschreiben.
Wir werden hier erstmal nur eine Konstruktion angeben, die es uns erleichtert Gleichheiten in abhängigen Summen zu konstruieren.
Diese kann man als Verallgemeinerung des Fakts sehen, dass Gleichheiten in Produkten durch Paare von Gleichheiten gegeben sind.

\begin{definition}
  Sei $B(x)$ ein Typ für $x:A$.
  Dann ist für $(u,z),(v,w):(x:A)\to B(x)$ 
  \begin{align*}
    (\_,\_)_=:(p:u=_Av)\times \transp_B(p)(z)=w \to (u,z)=(v,w)
  \end{align*}
  gegeben durch Induktion über das Argument und $p$ oder als Pattern-Matching:
  $(\refl_u,q)_=\colonequiv \ap_{t\mapsto (u,t)}q$ wobei auch $(\refl_u,\refl_z)_=\colonequiv \refl_{(u,z)}$ funktionieren würde.
\end{definition}

Das können wir in folgendem Lemma benutzen:

\begin{lemma}
  Sei $A$ ein Typ und $x:A$.
  Der Typ
  \[
     (y:A)\times (y=x)
  \]
  ist kontrahierbar.
\end{lemma}

\begin{beweis}
  Als Kontraktionszentrum verwenden wir $(x,\refl_x)$.
  Um die Kontraktion zu konstruieren, müssen wir für $(y,p):(y:A)\times y=x$ eine Gleichheit in
  $(y,p)=(x,\refl_x)$ angeben.
  Das werden wir mittels der Funktion $(\_,\_)_=$ schaffen.
  Wir brauchen also passende Argumente, einmal eine Gleichheit $y=x$, die durch $p$ bereits gegeben ist und dann noch eine Gleichheit
  \[
    \transp_{y\mapsto y=x}(p)(p)=\refl_x
  \]
  Die linke Seite ist aber nach \Cref{transport-gleichheitstyp} $p^{-1}\kon p$,
  was nach \Cref{gliecheits-gruppoid} gleich $\refl_x$ ist.
\end{beweis}
